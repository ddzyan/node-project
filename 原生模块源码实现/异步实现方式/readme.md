## 简介
异步任务：将任务分成2个部分，先执行第一个部分，然后再执行其他任务，等到第一个部分完成后，再执行第二个部分代码。

在nodejs版本迭代中有多种实现异步编程的方法如下：
1. 回调函数
2. 事件监听
3. 发布订阅
4. Promise对象
5. generator函数
6. async/await

以上的所有方式，都是为了解决如何在第一部分任务完成后，通知主线程继续执行第二部分代码。

### 回调函数
将第二部分代码封装在一个函数内，等第一部分完成后，再执行这个函数

优点：
1. 代码容易理解
2. 实现简单

缺点
1. 容易造成回调地狱
2. 代码耦合度高

### 发布/订阅模式
将第二部分代码封装在订阅的事件的回调函数中，当第一部分代码执行完毕时发送消息通知订阅事件，执行回调函数

优点：
1. 代码耦合度低

缺点：
1. 代码分散，不易维护
2. 代码不容易理解

### Promise对象
es6语法，通过将异步任务封装成一个Promise对象，对象内部管理着异步任务执行状态，当任务执行成功时会通过resolve回调，让任务执行失败时会通过reject回调。

Promise将原本回调函数的嵌入式调用，修改为了链式调用，使代码更容易理解

优点：
1. 链式调用，代码流程容易理解
2. 不会造成回调地狱
3. 代码耦合度低

缺点
1. 语法较为复杂
2. 每个then结果都需要通过return进行返回，才能在链式调用中获得，造成代码冗余

### generator函数
示例代码：generator.js

Generator 函数就是协程在 es6 中的实现，最大的特点就是可以交出函数的执行权(暂停执行代码)。函数执行返回一个遍历器对象，对象内具有 next 方法，每次执行 next ，才会执行内部的 yiel 后的异步方法，返回一个对象。对象具有 2 个属性，value 代表异步返回结果，done 代表遍历是否完成。

Generator 函数可以暂停和恢复执行，这是它可以封装异步任务的根本原因。
Generator 函数的 2 个特性，使他可以作为异步编程的完整解决方案：

1. 错误捕捉
2. 数据交换

优点：

1. 异步流程便是简洁

缺点：

1. 无法自动进行流程管理

Generator 函数是一个异步操作容器，它的自动执行需要一种机制，当异步操作有了结果，需要交还代码执行权力。可以实现的两种方法如下：

1. 回调函数。将异步操作封装成一个 thunk 函数，在 thunk 函数 内交还代码执行权。示例代码：thunk-callback-generator.js
2. promise 对象。将异步操作封装成一个 promise 对象，用 then 方法交还代码执行权，示例代码：promise-generator.js

#### thunk 函数

##### 参数求值策略

```js
function f(a, b) {
  return b;
}

f(3 * x * x - 2 * x - 1, x);
```

- 传值调用：参数在调用执行，就已经进行了计算，传入的为最终计算结果
- 传名调用：只有在使用到参数的时候，才会对参数进行计算。

由于 js 是传值调用 ，编译器需要通过封装实现传名调用。

将参数放到一个临时函数中，再将这个临时函数传入到函数体中，这个临时函数就被称为 thunk 函数

```js
function a() {
  console.log(...args);
}

function b(a) {
  return function() {
    a(...args);
  };
}

b(a)(1, 2, 3);
```

js 中的 thunk 函数：将一个多参数函数，替换为只接收一个回调函数作为参数的单参数函数

```js
function a(name, callback) {
  callback(name);
}

// 正常版本
a(name, callback);

// 单回调函数参数版本
function a() {}

function thunk(name) {
  return function(callback) {
    a(name, callback);
  };
}

const aThunk = thunk(name);
aThunk(callback);
```